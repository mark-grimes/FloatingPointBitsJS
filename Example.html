<!DOCTYPE html>
<meta charset="utf-8" />
<title>Floating point bit test</title>
<script language="javascript" type="text/javascript" src="FloatingPoint.js"></script>
<script language="javascript" type="text/javascript">

	var floatNumber=new Module.FloatBits;

	function init()
	{
		checkboxDiv=document.getElementById("bitCheckboxes");
		for( index=floatNumber.size()-1; index>=0; --index )
		{
			var x = document.createElement("INPUT");
			x.setAttribute("type", "checkbox");
			x.setAttribute("id", "bit"+index);
			x.setAttribute("onclick", "bitChanged("+index+")" );
			checkboxDiv.appendChild(x);
		}
		decimalChanged();
	}

	function bitChanged( bitNumber )
	{
		floatNumber.set(bitNumber,document.getElementById("bit"+bitNumber).checked)
		setDecimal();
		setBinary();
		setHex();
	}

	function setBits()
	{
		for( index=0; index<floatNumber.size(); ++index )
		{
			document.getElementById("bit"+index).checked=floatNumber.get(index);
		}
	}

	function decimalChanged()
	{
		value=parseFloat(document.getElementById("decimal").value);
		floatNumber.valueFrom(value);
		setBits();
		setBinary();
		setHex();
		setDecimal(); // set self in case gibberish was entered. Also gives exact representation.
	}

	function setDecimal()
	{
		// Javascript toString doesn't distinguish between -0 and +0,
		// so need to add that by hand.
		value=floatNumber.value();
		asString=value.toString(10)
		if( value==0 && floatNumber.get(31)==true ) asString="-"+asString;
		document.getElementById("decimal").value=asString;
	}

	function binaryChanged()
	{
		value=parseInt(document.getElementById("binary").value,2);
		floatNumber.bitValueFromInt(value);
		setBits();
		setDecimal();
		setHex();
		setBinary(); // set self in case gibberish was entered.
	}

	function setBinary()
	{
		value=floatNumber.asInt();
		// Despite the C++ returning an unsigned, javascript insists on converting it to signed
		if( value<0 ) value=value+Math.pow(2,32);
		// Check to see if it needs to be padded with leading zeros
		asString=value.toString(2);
		while( asString.length<32 ) asString="0"+asString;
		// finally set the text box to the new value
		document.getElementById("binary").value=asString;
	}

	function hexChanged()
	{
		value=parseInt(document.getElementById("hex").value,16);
		floatNumber.bitValueFromInt(value);
		setBits();
		setDecimal();
		setBinary();
		setHex(); // set self in case gibberish was entered.
	}

	function setHex()
	{
		value=floatNumber.asInt();
		// Despite the C++ returning an unsigned, javascript insists on converting it to signed
		if( value<0 ) value=value+Math.pow(2,32);
		// Check to see if it needs to be padded with leading zeros
		asString=value.toString(16);
		while( asString.length<8 ) asString="0"+asString;
		document.getElementById("hex").value="0x"+asString;
	}

	window.addEventListener("load", init, false);
</script>
<h2>Simple example of using the FloatingPoint library to find floats from their binary representation</h2>
<p>
	<div id="bitCheckboxes"></div>
	<br>
	<table>
		<tr><td>Decimal <td><input type="text" id="decimal" size=70 value="0" onchange="decimalChanged()"/>
		<tr><td>Binary <td><input type="text" id="binary" size=70 onchange="binaryChanged()"/>
		<tr><td>Hex <td><input type="text" id="hex" size=70 onchange="hexChanged()"/>
	</table>
	<br>
	The old page for comparison:
	<iframe class="oldCode" src="http://www.h-schmidt.net/FloatConverter/IEEE754.html" width="100%" height="500"></iframe>
</p>
